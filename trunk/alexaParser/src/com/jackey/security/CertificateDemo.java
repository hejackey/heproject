package com.jackey.security;

import java.io.FileInputStream;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Signature;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;

import java.util.Date;


import javax.crypto.Cipher;

/**
 * 
1.生成keyStroe文件 
在命令行下执行以下命令： 
Shell代码 
keytool -genkey -validity 36000 -alias www.zlex.org -keyalg RSA -keystore d:\zlex.keystore  

其中 
-genkey表示生成密钥 
-validity指定证书有效期，这里是36000天 
-alias指定别名，这里是www.zlex.org 
-keyalg指定算法，这里是RSA 
-keystore指定存储位置，这里是d:\zlex.keystore 

在这里我使用的密码为 123456


2.生成自签名证书 
光有keyStore文件是不够的，还需要证书文件，证书才是直接提供给外界使用的公钥凭证。 
导出证书： 
Shell代码 
keytool -export -keystore d:\zlex.keystore -alias www.zlex.org -file d:\zlex.cer -rfc  

keytool -export -keystore d:\zlex.keystore -alias www.zlex.org -file d:\zlex.cer -rfc

其中 
-export指定为导出操作 
-keystore指定keystore文件 
-alias指定导出keystore文件中的别名 
-file指向导出路径 
-rfc以文本格式输出，也就是以BASE64编码输出 
这里的密码是 123456 


 * @author Administrator
 *
 */
public class CertificateDemo {
	/**  
     * Java密钥库(Java Key Store，JKS)KEY_STORE  
     */  
    public static final String KEY_STORE = "JKS";   
  
    public static final String X509 = "X.509";   
  
    /**  
     * 由KeyStore获得私钥  
     *   
     * @param keyStorePath  
     * @param alias  
     * @param password  
     * @return  
     * @throws Exception  
     */  
    private static PrivateKey getPrivateKey(String keyStorePath, String alias,   
            String password) throws Exception {   
        KeyStore ks = getKeyStore(keyStorePath, password);   
        PrivateKey key = (PrivateKey) ks.getKey(alias, password.toCharArray());   
        return key;   
    }   
  
    /**  
     * 由Certificate获得公钥  
     *   
     * @param certificatePath  
     * @return  
     * @throws Exception  
     */  
    private static PublicKey getPublicKey(String certificatePath)   
            throws Exception {   
        Certificate certificate = getCertificate(certificatePath);   
        PublicKey key = certificate.getPublicKey();   
        return key;   
    }   
  
    /**  
     * 获得Certificate  
     *   
     * @param certificatePath  
     * @return  
     * @throws Exception  
     */  
    private static Certificate getCertificate(String certificatePath)   
            throws Exception {   
        CertificateFactory certificateFactory = CertificateFactory   
                .getInstance(X509);   
        System.out.println(certificateFactory.getProvider());
        FileInputStream in = new FileInputStream(certificatePath);   
  
        Certificate certificate = certificateFactory.generateCertificate(in);   
        System.out.println(certificate.getType());
        in.close();   
  
        return certificate;   
    }   
  
    /**  
     * 获得Certificate  
     *   
     * @param keyStorePath  
     * @param alias  
     * @param password  
     * @return  
     * @throws Exception  
     */  
    private static Certificate getCertificate(String keyStorePath,   
            String alias, String password) throws Exception {   
        KeyStore ks = getKeyStore(keyStorePath, password);   
        Certificate certificate = ks.getCertificate(alias);   
  
        return certificate;   
    }   
  
    /**  
     * 获得KeyStore  
     *   
     * @param keyStorePath  
     * @param password  
     * @return  
     * @throws Exception  
     */  
    private static KeyStore getKeyStore(String keyStorePath, String password)   
            throws Exception {   
        FileInputStream is = new FileInputStream(keyStorePath);   
        KeyStore ks = KeyStore.getInstance(KEY_STORE);   
        ks.load(is, password.toCharArray());   
        is.close();   
        return ks;   
    }   
  
    /**  
     * 私钥加密  
     *   
     * @param data  
     * @param keyStorePath  
     * @param alias  
     * @param password  
     * @return  
     * @throws Exception  
     */  
    public static byte[] encryptByPrivateKey(byte[] data, String keyStorePath,   
            String alias, String password) throws Exception {   
        // 取得私钥   
        PrivateKey privateKey = getPrivateKey(keyStorePath, alias, password);   
  
        // 对数据加密   
        Cipher cipher = Cipher.getInstance(privateKey.getAlgorithm());   
        cipher.init(Cipher.ENCRYPT_MODE, privateKey);   
  
        return cipher.doFinal(data);   
  
    }   
  
    /**  
     * 私钥解密  
     *   
     * @param data  
     * @param keyStorePath  
     * @param alias  
     * @param password  
     * @return  
     * @throws Exception  
     */  
    public static byte[] decryptByPrivateKey(byte[] data, String keyStorePath,   
            String alias, String password) throws Exception {   
        // 取得私钥   
        PrivateKey privateKey = getPrivateKey(keyStorePath, alias, password);   
  
        // 对数据加密   
        Cipher cipher = Cipher.getInstance(privateKey.getAlgorithm());   
        cipher.init(Cipher.DECRYPT_MODE, privateKey);   
  
        return cipher.doFinal(data);   
  
    }   
  
    /**  
     * 公钥加密  
     *   
     * @param data  
     * @param certificatePath  
     * @return  
     * @throws Exception  
     */  
    public static byte[] encryptByPublicKey(byte[] data, String certificatePath)   
            throws Exception {   
  
        // 取得公钥   
        PublicKey publicKey = getPublicKey(certificatePath);   
        // 对数据加密   
        Cipher cipher = Cipher.getInstance(publicKey.getAlgorithm());   
        cipher.init(Cipher.ENCRYPT_MODE, publicKey);   
  
        return cipher.doFinal(data);   
  
    }   
  
    /**  
     * 公钥解密  
     *   
     * @param data  
     * @param certificatePath  
     * @return  
     * @throws Exception  
     */  
    public static byte[] decryptByPublicKey(byte[] data, String certificatePath)   
            throws Exception {   
        // 取得公钥   
        PublicKey publicKey = getPublicKey(certificatePath);   
  
        // 对数据加密   
        Cipher cipher = Cipher.getInstance(publicKey.getAlgorithm());   
        cipher.init(Cipher.DECRYPT_MODE, publicKey);   
  
        return cipher.doFinal(data);   
  
    }   
  
    /**  
     * 验证Certificate  
     *   
     * @param certificatePath  
     * @return  
     */  
    public static boolean verifyCertificate(String certificatePath) {   
        return verifyCertificate(new Date(), certificatePath);   
    }   
  
    /**  
     * 验证Certificate是否过期或无效  
     *   
     * @param date  
     * @param certificatePath  
     * @return  
     */  
    public static boolean verifyCertificate(Date date, String certificatePath) {   
        boolean status = true;   
        try {   
            // 取得证书   
            Certificate certificate = getCertificate(certificatePath);   
            // 验证证书是否过期或无效   
            status = verifyCertificate(date, certificate);   
        } catch (Exception e) {   
            status = false;   
        }   
        return status;   
    }   
  
    /**  
     * 验证证书是否过期或无效  
     *   
     * @param date  
     * @param certificate  
     * @return  
     */  
    private static boolean verifyCertificate(Date date, Certificate certificate) {   
        boolean status = true;   
        try {   
            X509Certificate x509Certificate = (X509Certificate) certificate;   
            x509Certificate.checkValidity(date);   
        } catch (Exception e) {   
            status = false;   
        }   
        return status;   
    }   
  
    /**  
     * 签名  
     *   
     * @param keyStorePath  
     * @param alias  
     * @param password  
     *   
     * @return  
     * @throws Exception  
     */  
    public static String sign(byte[] sign, String keyStorePath, String alias,   
            String password) throws Exception {   
        // 获得证书   
        X509Certificate x509Certificate = (X509Certificate) getCertificate(   
                keyStorePath, alias, password);   
        // 获取私钥   
        KeyStore ks = getKeyStore(keyStorePath, password);   
        // 取得私钥   
        PrivateKey privateKey = (PrivateKey) ks.getKey(alias, password   
                .toCharArray());   
  
        // 构建签名   
        Signature signature = Signature.getInstance(x509Certificate   
                .getSigAlgName());   
        signature.initSign(privateKey);   
        signature.update(sign);   
        return Base64Demo.encryptBASE64(signature.sign());   
    }   
  
    /**  
     * 验证签名  
     *   
     * @param data  
     * @param sign  
     * @param certificatePath  
     * @return  
     * @throws Exception  
     */  
    public static boolean verify(byte[] data, String sign,   
            String certificatePath) throws Exception {   
        // 获得证书   
        X509Certificate x509Certificate = (X509Certificate) getCertificate(certificatePath);   
        // 获得公钥   
        PublicKey publicKey = x509Certificate.getPublicKey();   
        // 构建签名   
        Signature signature = Signature.getInstance(x509Certificate   
                .getSigAlgName());   
        signature.initVerify(publicKey);   
        signature.update(data);   
  
        return signature.verify(Base64Demo.decryptBASE64(sign));   
  
    }   
  
    /**  
     * 验证Certificate  
     *   
     * @param keyStorePath  
     * @param alias  
     * @param password  
     * @return  
     */  
    public static boolean verifyCertificate(Date date, String keyStorePath,   
            String alias, String password) {   
        boolean status = true;   
        try {   
            Certificate certificate = getCertificate(keyStorePath, alias,   
                    password);   
            status = verifyCertificate(date, certificate);   
        } catch (Exception e) {   
            status = false;   
        }   
        return status;   
    }   
  
    /**  
     * 验证Certificate  
     *   
     * @param keyStorePath  
     * @param alias  
     * @param password  
     * @return  
     */  
    public static boolean verifyCertificate(String keyStorePath, String alias,   
            String password) {   
        return verifyCertificate(new Date(), keyStorePath, alias, password);   
    }  
    
	/**
	 * @param args
	 * @throws Exception 
	 */
	public static void main(String[] args) throws Exception {
		String password = "123456";   
	    String alias = "www.jackeyhe.com";   
	    String certificatePath = "f:/jackey_he.cer";   
	    String keyStorePath = "f:/jackey_he.keystore";   
	    
	    System.err.println("公钥加密――私钥解密");   
        String inputStr = "Ceritifcate";   
        byte[] data = inputStr.getBytes();   
  
        byte[] encrypt = CertificateDemo.encryptByPublicKey(data,   
                certificatePath);   
  
        byte[] decrypt = CertificateDemo.decryptByPrivateKey(encrypt,   
                keyStorePath, alias, password);   
        String outputStr = new String(decrypt);   
  
        System.err.println("加密前: " + inputStr + "\n\r" + "解密后: " + outputStr);  
        
        /*System.err.println("私钥加密――公钥解密");   
        
        inputStr = "sign";   
        data = inputStr.getBytes();   
  
        byte[] encodedData = CertificateDemo.encryptByPrivateKey(data,   
                keyStorePath, alias, password);   
  
        byte[] decodedData = CertificateDemo.decryptByPublicKey(encodedData,   
                certificatePath);   
  
        outputStr = new String(decodedData);   
        System.err.println("加密前: " + inputStr + "\n\r" + "解密后: " + outputStr);   
        
        System.err.println("私钥签名――公钥验证签名");   
        // 产生签名   
        encodedData="abc".getBytes();
        String sign = CertificateDemo.sign(encodedData, keyStorePath, alias,   
                password);   
        System.err.println("签名:\r" + sign);   
  
        // 验证签名   
       
        boolean status = CertificateDemo.verify(encodedData, sign,   
                certificatePath);   
        System.err.println("状态:\r" + status);   
*/
	}

}
